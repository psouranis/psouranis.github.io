<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Numpy or ... ? What can I choose? | Panagiotis Souranis </title> <meta name="author" content="Panagiotis Souranis"> <meta name="description" content="Numpy optimizations"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?e085e6e336e4118fa5acc3f249df0647" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://psouranis.github.io/blog/2025/numpy-numexpr-numba-cython-copy/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Panagiotis</span> Souranis </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Curriculum Vitae </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Numpy or ... ? What can I choose?</h1> <p class="post-meta"> Created in May 20, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/inference"> <i class="fa-solid fa-hashtag fa-sm"></i> Inference</a>   <a href="/blog/tag/optimizations"> <i class="fa-solid fa-hashtag fa-sm"></i> Optimizations</a>   <a href="/blog/tag/performance"> <i class="fa-solid fa-hashtag fa-sm"></i> Performance</a>   <a href="/blog/tag/ml"> <i class="fa-solid fa-hashtag fa-sm"></i> ML</a>   ·   <a href="/blog/category/optimizations"> <i class="fa-solid fa-tag fa-sm"></i> Optimizations</a> </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h3"><a href="#speeding-up-complex-math-in-python-numpy-numba-cython-and-numexpr-compared">Speeding Up Complex Math in Python: NumPy, Numba, Cython, and NumExpr Compared</a></li> <li class="toc-entry toc-h3"><a href="#1-the-baseline-pure-numpy">1. The Baseline: Pure Numpy</a></li> <li class="toc-entry toc-h3"><a href="#2-trying-out-npvectorize">2. Trying out np.vectorize</a></li> <li class="toc-entry toc-h3"><a href="#3-supercharging-with-numba">3. Supercharging with Numba</a></li> <li class="toc-entry toc-h3"><a href="#4-going-deeper-with-cython">4. Going deeper with Cython</a></li> <li class="toc-entry toc-h3"><a href="#5-the-surprise-winner-numexpr">5. The Surprise Winner: NumExpr</a></li> <li class="toc-entry toc-h3"><a href="#so-whats-the-best-choice">So, What’s the Best Choice?</a></li> <li class="toc-entry toc-h3"><a href="#checkout-the-full-notebook-below">Checkout the full notebook below</a></li> </ul> </div> <hr> <div id="markdown-content"> <h3 id="speeding-up-complex-math-in-python-numpy-numba-cython-and-numexpr-compared">Speeding Up Complex Math in Python: NumPy, Numba, Cython, and NumExpr Compared</h3> <p>If you’ve ever worked with big arrays in Python, you know how important it is to make your code run fast—especially when you’re crunching numbers with complex math. Today, I’m going to walk you through a little experiment where I tried out several popular tools to see which one handles the expression the fastest. Let’s dive in!</p> <p>As an example we will use this easy to play with expression:</p> \[f(x) = e^{\sin(x) + \cos(x)}\] <h3 id="1-the-baseline-pure-numpy">1. The Baseline: Pure Numpy</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td> <td class="rouge-code"><pre><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">complex_function</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="p">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

</pre></td> </tr></tbody></table></code></pre></div></div> <p>How did it do?</p> <p>Processing an array of 1 million elements took about 22 miliseconds. Not bad, but let’s see if we can do better!</p> <h3 id="2-trying-out-npvectorize">2. Trying out np.vectorize</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre><span class="kn">import</span> <span class="n">math</span>
<span class="n">vec_f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">math</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">math</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>The result?</p> <p>Surprisingly, it was actually slower than pure NumPy! (223 ms)</p> <p>Why? Because <code class="language-plaintext highlighter-rouge">np.vectorize</code> is really just a convenient wrapper for a Python loop—not a true speed booster. Lesson learned: Stick with NumPy’s built-in vectorized functions for performance.</p> <h3 id="3-supercharging-with-numba">3. Supercharging with Numba</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td> <td class="rouge-code"><pre><span class="kn">from</span> <span class="n">numba</span> <span class="kn">import</span> <span class="n">vectorize</span><span class="p">,</span> <span class="n">float64</span>
<span class="nd">@vectorize</span><span class="p">([</span><span class="nf">float64</span><span class="p">(</span><span class="n">float64</span><span class="p">)])</span>
<span class="k">def</span> <span class="nf">numba_func</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    A Numba-optimized function that computes the sine and cosine of an element.

    Parameters:
    x (float): Input value.

    Returns:
    float: Exponential of the sine and cosine of the input value.
    </span><span class="sh">"""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="p">.</span><span class="nf">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># Combine sine and cosine functions
</span>    <span class="k">return</span> <span class="n">result</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>How fast? 16ms. About 27% faster than pure NumPy! That’s a nice bump in speed for almost no extra effort.</p> <h3 id="4-going-deeper-with-cython">4. Going deeper with Cython</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td> <td class="rouge-code"><pre><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">cimport</span> <span class="n">cython</span>

<span class="k">from</span> <span class="n">libc</span><span class="p">.</span><span class="n">math</span> <span class="n">cimport</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">exp</span>
<span class="kn">from</span> <span class="n">cython.parallel</span> <span class="kn">import</span> <span class="n">prange</span>

<span class="n">cimport</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">cnp</span>

<span class="n">cnp</span><span class="p">.</span><span class="nf">import_array</span><span class="p">()</span>
<span class="n">DTYPE</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">float64</span>

<span class="n">ctypedef</span> <span class="n">cnp</span><span class="p">.</span><span class="n">float64_t</span> <span class="n">DTYPE_t</span>

<span class="nd">@cython.boundscheck</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="nd">@cython.wraparound</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cython_complex_function</span><span class="p">(</span><span class="n">cnp</span><span class="p">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">DTYPE_t</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">]</span> <span class="n">f</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    A Cythonized function that computes the sine and cosine of an array.
    This version is parallelized using OpenMP.

    Parameters:
    f (np.ndarray): Input array of floats.

    Returns:
    np.ndarray: Resulting array after applying the operations.
    </span><span class="sh">"""</span>
    <span class="n">cdef</span> <span class="n">double</span> <span class="n">s</span>
    <span class="n">cdef</span> <span class="n">double</span> <span class="n">c</span>
    <span class="n">cdef</span> <span class="nb">int</span> <span class="n">i</span>
    <span class="n">cdef</span> <span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Allocate the array directly with cnp.ndarray
</span>    <span class="n">cdef</span> <span class="n">cnp</span><span class="p">.</span><span class="n">ndarray</span><span class="p">[</span><span class="n">DTYPE_t</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">]</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">cnp</span><span class="p">.</span><span class="nf">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">)</span>

    <span class="c1"># Use prange for parallel execution with OpenMP
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">prange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">nogil</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">sin</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nf">cos</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">exp</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">arr</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>Performance: About the same as Numba.</p> <p>But you do need to write some extra code and deal with compiling and its bit more cumbersome.</p> <blockquote> <p><em>Note</em></p> <p>We could further optimize the Cython version by doing more low level tricks but we chose to not apply more effort for this experiment</p> </blockquote> <h3 id="5-the-surprise-winner-numexpr">5. The Surprise Winner: NumExpr</h3> <p>Finally, I tried out NumExpr, which is designed to optimize and parallelize mathematical expressions:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre><span class="kn">import</span> <span class="n">numexpr</span> <span class="k">as</span> <span class="n">ne</span>

<span class="n">ne</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="sh">"</span><span class="s">exp(sin(x) + cos(x))</span><span class="sh">"</span><span class="p">,</span> <span class="n">local_dict</span><span class="o">=</span><span class="p">{</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">:</span> <span class="n">x</span><span class="p">})</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p>Its extremely surprising how easy was to code this one and the result is even more impressive. Blazing fast with only 2ms.</p> <h3 id="so-whats-the-best-choice">So, What’s the Best Choice?</h3> <ul> <li> <p>NumExpr is the clear winner for this kind of math-heavy, element-wise calculation. It’s super easy to use and incredibly fast.</p> </li> <li> <p>Numba and Cython are great if you want more control or are already using them in your project.</p> </li> </ul> <p>And remember: <code class="language-plaintext highlighter-rouge">np.vectorize</code> might look handy, but it won’t speed up your code.</p> <h3 id="checkout-the-full-notebook-below">Checkout the full notebook below</h3> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/numpy_go_brr.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/metaclasses/">Python metaclasses</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/getitem/">__getitem__ vs __getitems__. A nice trick for Pytorch</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/pruning-techniques-part2/">Pruning techniques - Optimizing machine learning models Part 2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/pruning-techniques/">Pruning techniques - Optimizing machine learning models Part 1</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/tail-call-optimization/">Tail Call Optimization</a> </li> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>let giscusTheme=determineComputedTheme(),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"psouranis/psouranis.github.io","data-repo-id":"","data-category":"Comments","data-category-id":"","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Panagiotis Souranis. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a>. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"About",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"nav-projects",title:"Projects",description:"A growing collection of your cool projects.",section:"Navigation",handler:()=>{window.location.href="/projects/"}},{id:"nav-repositories",title:"Repositories",description:"",section:"Navigation",handler:()=>{window.location.href="/repositories/"}},{id:"nav-curriculum-vitae",title:"Curriculum Vitae",description:"",section:"Navigation",handler:()=>{window.location.href="/cv/"}},{id:"post-python-metaclasses",title:"Python metaclasses",description:"Python metaclasses",section:"Posts",handler:()=>{window.location.href="/blog/2025/metaclasses/"}},{id:"post-numpy-or-what-can-i-choose",title:"Numpy or ... ? What can I choose?",description:"Numpy optimizations",section:"Posts",handler:()=>{window.location.href="/blog/2025/numpy-numexpr-numba-cython-copy/"}},{id:"post-getitem-vs-getitems-a-nice-trick-for-pytorch",title:"__getitem__ vs __getitems__. A nice trick for Pytorch",description:"Torch indexing trick",section:"Posts",handler:()=>{window.location.href="/blog/2025/getitem/"}},{id:"post-pruning-techniques-optimizing-machine-learning-models-part-2",title:"Pruning techniques - Optimizing machine learning models Part 2",description:"Pruning Techniques Part 2",section:"Posts",handler:()=>{window.location.href="/blog/2025/pruning-techniques-part2/"}},{id:"post-pruning-techniques-optimizing-machine-learning-models-part-1",title:"Pruning techniques - Optimizing machine learning models Part 1",description:"Pruning Techniques",section:"Posts",handler:()=>{window.location.href="/blog/2025/pruning-techniques/"}},{id:"post-tail-call-optimization",title:"Tail Call Optimization",description:"Tail Call Optimization",section:"Posts",handler:()=>{window.location.href="/blog/2025/tail-call-optimization/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%73%6F%75%72%61%6E%69%73%70%61%6E%6F%73@%67%6D%61%69%6C.%63%6F%6D","_blank")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>