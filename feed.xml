<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://psouranis.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://psouranis.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-14T16:54:53+00:00</updated><id>https://psouranis.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Tail Call Optimization - What is it?</title><link href="https://psouranis.github.io/blog/2025/tail-call-optimization/" rel="alternate" type="text/html" title="Tail Call Optimization - What is it?"/><published>2025-02-14T12:40:16+00:00</published><updated>2025-02-14T12:40:16+00:00</updated><id>https://psouranis.github.io/blog/2025/tail-call-optimization</id><content type="html" xml:base="https://psouranis.github.io/blog/2025/tail-call-optimization/"><![CDATA[<h3 id="tail-recursive-methods">Tail Recursive Methods</h3> <p>In this post we will talk about optimizations in C and specifically about Tail Call Optimization. But let’s start from defining what is a tail recursion.</p> <p>A recursive method is referred to as tail-recursive <em>when the recursive call is the last thing executed by the that method</em>, otherwise, it’s known as <em>head recursive</em></p> <p>Here is a simple example of a <em>tail recursive method</em>:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printNumbers</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>	
	<span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">printNumbers</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Notice in this function how the last thing executed by the method is a recrusive call, making it a <em>tail recursive method</em>. Let’s take another example now, the factorial function. The factorial function can be implemented as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Is this a tail recursive method? On the first look someone would say yes but if we were to look more closely we would see that the function can be written as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>We realize that the last executed statement by this method is the multiplication and not the recursion meaning that the method we previously implemented is not <em>tail recursive</em> but rather <em>head recursive</em>. So let’s try first to transform it to a tail recursive method and then discuss it’s benefits.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">factorialTail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">factorialTail</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Notice that now we have 2 methods instead of 1 (<code class="language-plaintext highlighter-rouge">factorial</code> and <code class="language-plaintext highlighter-rouge">factorialTail</code>). The original method is turned to a helper method and is now called with an initial value. This initial value, in most cases, will be the return value of the stop condition we had in the original recursive call.</p> <p>The next thing you will notice, <em>is how we included the multiplication</em> which was the operation executed after the recursive call, inside the the recursion itself as an <strong>accumulator</strong> and it is the final result of this <strong>accumulator</strong> that is being returned to the user when the calculation is finished.</p> <p>In a tail recusrive method, <em>the result of the stop condition is actually the result of the whole recursion</em> because that is what it will be returned by all child calls all the way to the parent and initial call.</p> <p>Let’s take another example as well, the Fibonnaci sequence:</p> \[\text{Fibonacci}(n) = \text{Fibonnaci}(n-1) + \text{Fibonnaci}(n-2)\] <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fibonnaci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fibonnaci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonnaci</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Can be transformed to a tail recursive method as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fibonnaci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">fibonnaciTail</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">fibonnaciTail</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fibonnaci_</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Similar to the factorial one, the original method is broken into two, the caller and the helper one. The caller method is using as initial values the return values of the stop-conditions we previously had. The result or the addition is now accumulated inside the recursive call and because the recursion is called on the previous value of our current value as well in the initial method – we need to keep track the previous value of the initial call using an additional parameter.</p> <h3 id="continuation-passing-style">Continuation Passing Style</h3> <ol> <li> <p>The continuation passing style (passing accumulators as parameter values) might be the <strong>only generic way</strong> that allows you to transform the method into a form that uses <strong>only-tail calls</strong>.</p> </li> <li> <p>Not all logics can be made tail-recursive, non-linear recursions for instance maintain a variable somewhere and that somewhere is the <strong>Stack Memory</strong>.</p> </li> </ol> <h3 id="stack-visualization">Stack Visualization</h3> <p>Take a look at how the stack frame with tail call optimization and without.</p> <p><img src="/assets/post_images/tco.png" alt=""/></p> <p>When <code class="language-plaintext highlighter-rouge">factorial(5)</code> let’s say is called without tail call optimization — these calls will be respectively added to the stack, and we won’t be able to start popping from this stack before we reach the stop condition of the recursion.</p> <p>When that happens the values we have will start to get replaced and the stack calls will be popped.</p> \[\text{factorial}(5) \rightarrow \text{factorial}(4) \rightarrow \text{factorial}(3) \rightarrow \text{factorial}(2) \rightarrow \text{factorial}(1)\] <p>However, if we try this on the tail recursive method, the first call will be the call to the factorial method <code class="language-plaintext highlighter-rouge">factorial</code> and the second call will be the call to the <code class="language-plaintext highlighter-rouge">factorialTail</code>:</p> \[\text{factorial}(5) \rightarrow \text{factorialTail}(5,1)\] <p>When <code class="language-plaintext highlighter-rouge">factorial(4)</code> is called, because no variables are required to be stored in the frame left by the parent call of the same recursive method, and because both of these calls will have the same return value — then this same frame will be used to store the new call details:</p> \[\text{factorial}(5) \rightarrow \text{factorialTail}(1, 120)\] <p>Now, if we go back and compare the stacks corresponding to the recursive methods at their maximum depths, we will see that the space complexity of recursion was reduced from \(O(n)\) to \(O(1)\) thanks to tail-call elimination.</p> <p><img src="/assets/post_images/tco_complexity.png" alt=""/></p> <h3 id="summary">Summary</h3> <h4 id="what-are-the-benefits-ot-tail-recursion-methods">What are the benefits ot Tail Recursion Methods?</h4> <ul> <li>Tail recursive methods are <strong>optimized</strong> by certain compilers. These compilers usually execute calls with the help of a stack.</li> <li>In case of tail-recursive methods, there is no need to reserve a place in the stack for the recursive call because there is nothing left to do in the current method and we won’t be returning to the parent call.</li> <li>The space complexity reduces from \(O(n)\) to \(O(1).\)</li> </ul>]]></content><author><name></name></author><category term="performance"/><category term="C"/><category term="Optimizations"/><summary type="html"><![CDATA[Tail Call Optimization]]></summary></entry></feed>